
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cpuix/multigit/cmd/add.go (14.3%)</option>
				
				<option value="file1">github.com/cpuix/multigit/cmd/delete.go (13.3%)</option>
				
				<option value="file2">github.com/cpuix/multigit/cmd/list.go (3.4%)</option>
				
				<option value="file3">github.com/cpuix/multigit/cmd/profile.go (73.0%)</option>
				
				<option value="file4">github.com/cpuix/multigit/cmd/root.go (44.1%)</option>
				
				<option value="file5">github.com/cpuix/multigit/cmd/status.go (7.1%)</option>
				
				<option value="file6">github.com/cpuix/multigit/cmd/use.go (61.0%)</option>
				
				<option value="file7">github.com/cpuix/multigit/internal/config/ssh_config.go (0.0%)</option>
				
				<option value="file8">github.com/cpuix/multigit/internal/multigit/account.go (73.6%)</option>
				
				<option value="file9">github.com/cpuix/multigit/internal/multigit/commands.go (0.0%)</option>
				
				<option value="file10">github.com/cpuix/multigit/internal/ssh/mock_ssh.go (0.0%)</option>
				
				<option value="file11">github.com/cpuix/multigit/internal/ssh/ssh.go (68.7%)</option>
				
				<option value="file12">github.com/cpuix/multigit/internal/ssh/ssh_interface.go (40.0%)</option>
				
				<option value="file13">github.com/cpuix/multigit/main.go (0.0%)</option>
				
				<option value="file14">github.com/cpuix/multigit/testutil/testutil.go (36.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/spf13/cobra"
)

var passphrase string

var createCmd = &amp;cobra.Command{
        Use:   "create &lt;account_name&gt; &lt;account_email&gt;",
        Short: "Create a new GitHub account SSH key",
        Long: `Create a new GitHub account SSH key and add it to the SSH agent and config file.
This will:
1. Generate a new 4096-bit RSA key pair
2. Add the key to the SSH agent
3. Update the SSH config file
4. Save the account information to the multigit config`,
        Args: cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                accountName := args[0]
                accountEmail := args[1]

                // Validate email format (basic check)
                if len(accountEmail) &lt; 3 || !strings.Contains(accountEmail, "@") </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email format")
                }</span>

                // Create the account
                <span class="cov0" title="0">if err := multigit.CreateAccount(accountName, accountEmail, passphrase); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create account: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("\nüéâ Account '%s' has been created and configured successfully!\n", accountName)
                fmt.Println("\nTo use this account, run:")
                fmt.Printf("  multigit use %s\n", accountName)
                fmt.Println("\nTo add this key to your GitHub account, copy the public key above")
                fmt.Println("and add it at: https://github.com/settings/ssh/new")

                return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        RootCmd.AddCommand(createCmd)
        createCmd.Flags().StringVarP(&amp;passphrase, "passphrase", "p", "", "Passphrase for the SSH key (recommended for security)")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/spf13/cobra"
)

var (
        forceDelete bool
)

var deleteCmd = &amp;cobra.Command{
        Use:     "delete &lt;account_name&gt;",
        Aliases: []string{"remove", "rm"},
        Short:   "Delete a GitHub account",
        Long: `Delete a GitHub account and its associated SSH keys and config.
This will:
1. Remove the SSH key from the SSH agent
2. Delete the SSH key files
3. Remove the SSH config entry
4. Remove the account from the multigit config`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                accountName := args[0]

                // Confirm before deleting
                if !forceDelete </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  WARNING: This will permanently delete the account '%s' and its SSH keys.\n", accountName)
                        fmt.Print("Are you sure you want to continue? [y/N] ")

                        var response string
                        _, err := fmt.Scanln(&amp;response)
                        if err != nil || (response != "y" &amp;&amp; response != "Y") </span><span class="cov0" title="0">{
                                fmt.Println("Operation cancelled.")
                                return nil
                        }</span>
                }

                // Delete the account
                <span class="cov0" title="0">if err := multigit.DeleteAccount(accountName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete account: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("‚úÖ Account '%s' has been deleted successfully\n", accountName)
                return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        RootCmd.AddCommand(deleteCmd)
        deleteCmd.Flags().BoolP("force", "f", false, "Force deletion without confirmation")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all configured GitHub accounts",
        Long:  `List all configured GitHub accounts and show which one is currently active.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                config := multigit.LoadConfig()

                if len(config.Accounts) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No accounts configured. Use 'multigit create' to add an account.")
                        return nil
                }</span>

                // Get active account info if any
                <span class="cov0" title="0">activeAccountName, activeAccount, _ := multigit.GetActiveAccount()

                // Print header
                headerFmt := color.New(color.FgGreen, color.Underline).SprintfFunc()
                fmt.Println(headerFmt("Configured GitHub Accounts:"))
                fmt.Println()

                // Print each account
                for name, account := range config.Accounts </span><span class="cov0" title="0">{
                        // Check if this is the active account
                        isActive := activeAccountName == name

                        // Format account info
                        status := ""
                        if isActive </span><span class="cov0" title="0">{
                                status = color.GreenString("‚úì")
                        }</span> else<span class="cov0" title="0"> {
                                status = " "
                        }</span>

                        // Print account details
                        <span class="cov0" title="0">fmt.Printf("%s %s\n", status, color.CyanString(name))
                        fmt.Printf("  Email: %s\n", account.Email)
                        
                        // Show SSH key info if available
                        homeDir, _ := os.UserHomeDir()
                        keyPath := fmt.Sprintf("%s/.ssh/id_rsa_%s", homeDir, name)
                        if _, err := os.Stat(keyPath); err == nil </span><span class="cov0" title="0">{
                                fmt.Printf("  SSH Key: %s\n", keyPath)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("  SSH Key: %s (not found)\n", color.YellowString(keyPath))
                        }</span>

                        // Show active status
                        <span class="cov0" title="0">if isActive </span><span class="cov0" title="0">{
                                fmt.Printf("  Status: %s\n", color.GreenString("Active"))
                        }</span>

                        <span class="cov0" title="0">fmt.Println()</span>
                }


                // Print usage instructions
                <span class="cov0" title="0">if activeAccountName != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Active account: %s &lt;%s&gt;\n", 
                                color.CyanString(activeAccountName), 
                                color.CyanString(activeAccount.Email))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No active account. Use 'multigit use &lt;account&gt;' to set an active account.")
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        RootCmd.AddCommand(listCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

var profileCmd = &amp;cobra.Command{
        Use:   "profile",
        Short: "Manage git profiles",
        Long:  `Create, list, or delete git profiles that contain multiple account configurations.`,
}

var createProfileCmd = &amp;cobra.Command{
        Use:   "create [profile-name]",
        Short: "Create a new profile",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                profileName := args[0]
                config := multigit.LoadConfig()

                // Check if profile already exists
                if _, exists := config.Profiles[profileName]; exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("profile '%s' already exists", profileName)
                }</span>

                // Create new profile
                <span class="cov8" title="1">config.Profiles[profileName] = multigit.Profile{
                        Name:     profileName,
                        Accounts: make(map[string]bool),
                }

                // Save the updated config
                if err := multigit.SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save profile: %v", err)
                }</span>

                <span class="cov8" title="1">color.Green("‚úì Created profile: %s\n", profileName)
                return nil</span>
        },
}

var listProfilesCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all profiles",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                config := multigit.LoadConfig()

                if len(config.Profiles) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No profiles found. Create one with 'multigit profile create &lt;name&gt;'")
                        return nil
                }</span>

                // Get active profile name
                <span class="cov8" title="1">activeProfile := ""
                if config.ActiveProfile != "" </span><span class="cov0" title="0">{
                        activeProfile = config.ActiveProfile
                }</span>

                // Print profiles
                <span class="cov8" title="1">headerFmt := color.New(color.FgGreen, color.Underline).SprintfFunc()
                fmt.Println(headerFmt("Available Profiles:"))
                fmt.Println()

                for name, profile := range config.Profiles </span><span class="cov8" title="1">{
                        // Check if this is the active profile
                        status := " "
                        if name == activeProfile </span><span class="cov0" title="0">{
                                status = color.GreenString("‚úì")
                        }</span>

                        // Count accounts in this profile
                        <span class="cov8" title="1">accountCount := len(profile.Accounts)

                        // Print profile info
                        fmt.Printf("%s %s\n", status, color.CyanString(name))
                        fmt.Printf("  Accounts: %d\n", accountCount)
                        fmt.Println()</span>
                }

                <span class="cov8" title="1">if activeProfile != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Active profile: %s\n", color.GreenString(activeProfile))
                }</span> else<span class="cov8" title="1"> {
                        fmt.Println("No active profile. Use 'multigit profile use &lt;name&gt;' to set one.")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

var useProfileCmd = &amp;cobra.Command{
        Use:   "use [profile-name]",
        Short: "Set active profile",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                profileName := args[0]
                config := multigit.LoadConfig()

                // Check if profile exists
                if _, exists := config.Profiles[profileName]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile '%s' does not exist", profileName)
                }</span>

                // Set active profile
                <span class="cov8" title="1">config.ActiveProfile = profileName

                // Save the updated config
                if err := multigit.SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update active profile: %v", err)
                }</span>

                <span class="cov8" title="1">color.Green("‚úì Active profile set to: %s\n", profileName)
                return nil</span>
        },
}

var deleteProfileCmd = &amp;cobra.Command{
        Use:     "delete [profile-name]",
        Aliases: []string{"remove", "rm"},
        Short:   "Delete a profile",
        Args:    cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                profileName := args[0]
                config := multigit.LoadConfig()

                // Check if profile exists
                if _, exists := config.Profiles[profileName]; !exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile '%s' does not exist", profileName)
                }</span>

                // Ask for confirmation
                <span class="cov8" title="1">if !profileForceDelete </span><span class="cov8" title="1">{
                        if !Confirm(fmt.Sprintf("Are you sure you want to delete profile '%s'?", profileName)) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                // If this was the active profile, clear active profile
                <span class="cov8" title="1">if config.ActiveProfile == profileName </span><span class="cov8" title="1">{
                        config.ActiveProfile = ""
                }</span>

                // Delete the profile
                <span class="cov8" title="1">delete(config.Profiles, profileName)


                // Save the updated config
                if err := multigit.SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete profile: %v", err)
                }</span>

                <span class="cov8" title="1">color.Green("‚úì Deleted profile: %s\n", profileName)
                return nil</span>
        },
}

var (
        profileForceDelete bool
)

func init() <span class="cov8" title="1">{
        RootCmd.AddCommand(profileCmd)
        profileCmd.AddCommand(createProfileCmd, listProfilesCmd, useProfileCmd, deleteProfileCmd)

        // Add flags
        deleteProfileCmd.Flags().BoolVarP(&amp;profileForceDelete, "force", "f", false, "force deletion without confirmation")
}</span>

// ConfirmFunc defines the function type for confirmation prompts
type ConfirmFunc func(string) bool

// Confirm is the function used to prompt for user confirmation
var Confirm ConfirmFunc = func(question string) bool <span class="cov0" title="0">{
        var response string
        fmt.Printf("%s [y/N]: ", question)
        _, err := fmt.Scanln(&amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return response == "y" || response == "Y"</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "os"

        "path/filepath"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        // CfgFile holds the path to the config file
        CfgFile string
        // Config holds the application configuration
        Config *multigit.Config
)

// RootCmd represents the base command when called without any subcommands
var RootCmd = &amp;cobra.Command{
    Use:   "multigit",
    Short: "MultiGit is a CLI for managing multiple GitHub accounts",
    Long:  `MultiGit helps you to manage multiple GitHub accounts effortlessly.`,
}

// Execute executes the root command
func Execute() <span class="cov0" title="0">{
        if err := RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
    cobra.OnInitialize(InitConfig)
        RootCmd.PersistentFlags().StringVar(&amp;CfgFile, "config", "", "config file (default is $HOME/.multigit.json)")
}</span>

// InitConfig initializes the configuration
func InitConfig() <span class="cov8" title="1">{
        // Initialize a default config
        Config = &amp;multigit.Config{
                Accounts:      make(map[string]multigit.Account),
                Profiles:      make(map[string]multigit.Profile),
                ActiveAccount: "",
        }

        if CfgFile != "" </span><span class="cov8" title="1">{
                // Use config file from the flag
                viper.SetConfigFile(CfgFile)
                
                // Create directory if it doesn't exist
                dir := filepath.Dir(CfgFile)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error creating config directory: %v\n", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Find home directory
                home, err := os.UserHomeDir()
                cobra.CheckErr(err)

                // Search config in home directory with name "config" (without extension)
                configDir := filepath.Join(home, ".config", "multigit")
                viper.AddConfigPath(configDir)
                viper.AddConfigPath(home)
                viper.SetConfigType("json")
                viper.SetConfigName("config")
        }</span>

        <span class="cov8" title="1">viper.AutomaticEnv()

        // If a config file is found, read it in
        if err := viper.ReadInConfig(); err == nil </span><span class="cov8" title="1">{
                fmt.Println("Using config file:", viper.ConfigFileUsed())
                // Unmarshal the config into our Config variable
                if err := viper.Unmarshal(Config); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error unmarshaling config:", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Create default config if it doesn't exist
                if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov0" title="0">{
                        // Config file not found; create default
                        if CfgFile != "" </span><span class="cov0" title="0">{
                                // Create the config file at the specified path
                                if err := viper.WriteConfigAs(CfgFile); err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("Error creating config file:", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Use default config path
                                if err := multigit.SaveConfig(*Config); err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("Error creating default config:", err)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Config file was found but another error was produced
                        fmt.Println("Error reading config file:", err)
                }</span>
        }

        // Ensure accounts and profiles maps are initialized
        <span class="cov8" title="1">if Config.Accounts == nil </span><span class="cov0" title="0">{
                Config.Accounts = make(map[string]multigit.Account)
        }</span>
        <span class="cov8" title="1">if Config.Profiles == nil </span><span class="cov0" title="0">{
                Config.Profiles = make(map[string]multigit.Profile)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show the currently active GitHub account",
        Long:  `Display information about the currently active GitHub account.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Get active account
                activeAccountName, account, err := multigit.GetActiveAccount()
                if err != nil </span><span class="cov0" title="0">{
                        color.Yellow("No active GitHub account. Use 'multigit use &lt;account&gt;' to set an active account.")
                        return nil
                }</span>

                // Print active account info
                <span class="cov0" title="0">fmt.Println(color.GreenString("Active GitHub account:"))
                fmt.Printf("  Name:  %s\n", color.CyanString(activeAccountName))
                fmt.Printf("  Email: %s\n", color.CyanString(account.Email))

                // Check if SSH key exists
                homeDir, _ := os.UserHomeDir()
                keyPath := fmt.Sprintf("%s/.ssh/id_rsa_%s", homeDir, activeAccountName)
                if _, err := os.Stat(keyPath); err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  SSH Key: %s\n", keyPath)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  SSH Key: %s\n", color.YellowString(keyPath+" (not found)"))
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        RootCmd.AddCommand(statusCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "fmt"
        "os"
        "os/exec"

        "github.com/cpuix/multigit/internal/multigit"
        "github.com/cpuix/multigit/internal/ssh"
        "github.com/spf13/cobra"
)

// SSHCreateFunc is a function type for creating SSH keys
var SSHCreateFunc = func(accountName, email, passphrase string) error <span class="cov0" title="0">{
        return ssh.CreateSSHKey(accountName, email, passphrase)
}</span>

// SSHAddToAgentFunc is a function type for adding SSH keys to the agent
var SSHAddToAgentFunc = func(accountName string) error <span class="cov0" title="0">{
        return ssh.AddSSHKeyToAgent(accountName)
}</span>

var (
        useLocal bool
        profile  string
)

var useCmd = &amp;cobra.Command{
        Use:   "use &lt;account_name&gt;",
        Short: "Switch to the specified GitHub account",
        Long: `Switch to the specified GitHub account by setting up the SSH key and git configuration.
This will:
1. Add the specified account's SSH key to the SSH agent
2. Set the git user name and email (global or local)
3. Update the active account in the configuration`,
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                accountName := args[0]
                
                // Check if account exists in config
                config := multigit.LoadConfig()
                account, exists := config.Accounts[accountName]
                if !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("account '%s' does not exist. Use 'multigit create' to add it first", accountName)
                }</span>

                // Add SSH key to agent
                <span class="cov8" title="1">if err := SSHAddToAgentFunc(accountName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add SSH key to agent: %w", err)
                }</span>

                // Set git config
                <span class="cov8" title="1">if err := setGitConfig(account, useLocal); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set git config: %w", err)
                }</span>

                // Update active account in config
                <span class="cov8" title="1">config.ActiveAccount = accountName
                if err := multigit.SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save config: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("‚úÖ Switched to account: %s &lt;%s&gt;\n", account.Name, account.Email)
                return nil</span>
        },
}

// setGitConfig sets the git user name and email (global or local)
func setGitConfig(account multigit.Account, local bool) error <span class="cov8" title="1">{
        // Prepare git config args
        configArgs := []string{"config"}
        if !local </span><span class="cov8" title="1">{
                configArgs = append(configArgs, "--global")
        }</span>

        // Set git config
        <span class="cov8" title="1">if err := RunGitCommand(append(configArgs, "user.name", account.Name)...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set git user name: %w", err)
        }</span>

        <span class="cov8" title="1">if err := RunGitCommand(append(configArgs, "user.email", account.Email)...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set git email: %w", err)
        }</span>

        // Only set URL rewrite for global config
        <span class="cov8" title="1">if !local </span><span class="cov8" title="1">{
                if err := RunGitCommand(append(configArgs, "url.ssh://git@github.com/.insteadOf", "https://github.com/")...); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set git URL rewrite: %w", err)
                }</span>
        }

        // Set push default to current
        <span class="cov8" title="1">if err := RunGitCommand("config", "--global", "push.default", "current"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set git push.default: %w", err)
        }</span>

        // Set github.com to use the correct SSH key
        <span class="cov8" title="1">sshCommand := fmt.Sprintf("ssh -i ~/.ssh/id_rsa_%s -F /dev/null", account.Name)
        if err := RunGitCommand("config", "--global", "core.sshCommand", sshCommand); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set git core.sshCommand: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RunGitCommand is a variable that holds the function to run git commands
var RunGitCommand = func(args ...string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

// IsGitRepo is a variable that holds the function to check if current directory is a git repo
var IsGitRepo = func() bool <span class="cov0" title="0">{
        _, err := os.Stat(".git")
        return err == nil || !os.IsNotExist(err)
}</span>

func init() <span class="cov8" title="1">{
        RootCmd.AddCommand(useCmd)
        useCmd.Flags().BoolVarP(&amp;useLocal, "local", "l", false, "Set git config locally (for current repository only)")
        useCmd.Flags().StringVarP(&amp;profile, "profile", "p", "", "Profile to use (optional)")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import "os"

// SSHConfigPath const SSHConfigPath = "~/.ssh/config"
const SSHConfigPath = "../../config"

func AppendConfigEntry(entry string) error <span class="cov0" title="0">{
    file, err := os.OpenFile(SSHConfigPath, os.O_APPEND|os.O_WRONLY, 0600)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov0" title="0">defer file.Close()

    if _, err = file.WriteString(entry); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package multigit

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"

        "github.com/cpuix/multigit/internal/ssh"
)

// Account represents a GitHub account with its associated information
type Account struct {
        Name  string `json:"name"`
        Email string `json:"email"`
}

// Profile represents a collection of accounts
type Profile struct {
        Name     string         `json:"name"`
        Accounts map[string]bool `json:"accounts"` // map[accountName]enabled
}

// Config represents the multigit configuration
type Config struct {
        Accounts      map[string]Account      `json:"accounts"`
        ActiveAccount string                 `json:"active_account"`
        Profiles      map[string]Profile     `json:"profiles"`
        ActiveProfile string                 `json:"active_profile"`
}

// SSHClient is the interface for SSH operations
var SSHClient ssh.SSHOperations = &amp;ssh.DefaultSSH{}

// CreateAccount creates a new GitHub account with SSH key and configures it
func CreateAccount(accountName, accountEmail, passphrase string) error <span class="cov8" title="1">{
        // Check if account already exists
        config := LoadConfig()
        if _, exists := config.Accounts[accountName]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("account '%s' already exists", accountName)
        }</span>

        // Create SSH key pair
        <span class="cov8" title="1">if err := SSHClient.CreateSSHKey(accountName, accountEmail, passphrase); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create SSH key: %w", err)
        }</span>

        // Add SSH key to agent
        <span class="cov8" title="1">if err := SSHClient.AddSSHKeyToAgent(accountName); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to add SSH key to agent: %w", err)
        }</span>

        // Add SSH config entry
        <span class="cov8" title="1">if err := SSHClient.AddSSHConfigEntry(accountName); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to add SSH config entry: %w", err)
        }</span>

        // Add or update account in config
        <span class="cov8" title="1">if config.Accounts == nil </span><span class="cov0" title="0">{
                config.Accounts = make(map[string]Account)
        }</span>

        <span class="cov8" title="1">config.Accounts[accountName] = Account{
                Name:  accountName,
                Email: accountEmail,
        }

        // Save config
        if err := SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("‚úÖ Account '%s' created successfully\n", accountName)
        return nil</span>
}

// DeleteAccount deletes a GitHub account and its associated SSH keys and config
func DeleteAccount(accountName string) error <span class="cov8" title="1">{
        // Load config
        config := LoadConfig()

        // Check if account exists
        if _, exists := config.Accounts[accountName]; !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("account '%s' does not exist", accountName)
        }</span>

        // Remove SSH key pair
        <span class="cov8" title="1">if err := SSHClient.DeleteSSHKey(accountName); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to delete SSH key: %v", err)
        }</span>

        // Remove SSH config entry
        <span class="cov8" title="1">if err := SSHClient.RemoveSSHConfigEntry(accountName); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to remove SSH config entry: %v", err)
        }</span>

        // Remove account from config
        <span class="cov8" title="1">delete(config.Accounts, accountName)

        // If the deleted account was active, clear the active account
        if config.ActiveAccount == accountName </span><span class="cov0" title="0">{
                config.ActiveAccount = ""
        }</span>

        // Save updated config
        <span class="cov8" title="1">if err := SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save config: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("‚úÖ Account '%s' deleted successfully\n", accountName)
        return nil</span>
}

// NewConfig creates a new empty configuration
func NewConfig() Config <span class="cov8" title="1">{
        return Config{
                Accounts: make(map[string]Account),
                Profiles: make(map[string]Profile),
        }
}</span>

// getConfigPath returns the path to the multigit config file
func getConfigPath() (string, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user home directory: %v", err)
        }</span>
        <span class="cov8" title="1">return filepath.Join(home, ".config", "multigit", "config.json"), nil</span>
}

// LoadConfigFromFile loads the configuration from a specific file
func LoadConfigFromFile(filePath string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// LoadConfig loads the multigit configuration from disk
func LoadConfig() Config <span class="cov8" title="1">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting config path: %v\n", err)
                return NewConfig()
        }</span>

        // If config file doesn't exist, return default config
        <span class="cov8" title="1">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return NewConfig()
        }</span>

        // Read config file
        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading config file: %v\n", err)
                return NewConfig()
        }</span>

        // Unmarshal config
        <span class="cov8" title="1">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing config file: %v\n", err)
                return NewConfig()
        }</span>

        // Initialize maps if they are nil
        <span class="cov8" title="1">if config.Accounts == nil </span><span class="cov0" title="0">{
                config.Accounts = make(map[string]Account)
        }</span>
        <span class="cov8" title="1">if config.Profiles == nil </span><span class="cov8" title="1">{
                config.Profiles = make(map[string]Profile)
        }</span>

        <span class="cov8" title="1">return config</span>
}

// SaveConfig saves the multigit configuration to the default location
func SaveConfig(config Config) error <span class="cov8" title="1">{
        filePath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get config path: %w", err)
        }</span>
        <span class="cov8" title="1">return SaveConfigToFile(config, filePath)</span>
}

// SaveConfigToFile saves the configuration to a specific file
func SaveConfigToFile(config Config, filePath string) error <span class="cov8" title="1">{
        // Create config directory if it doesn't exist
        configDir := filepath.Dir(filePath)
        if err := os.MkdirAll(configDir, 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Ensure active profile exists if set
        <span class="cov8" title="1">if config.ActiveProfile != "" </span><span class="cov8" title="1">{
                if _, exists := config.Profiles[config.ActiveProfile]; !exists </span><span class="cov0" title="0">{
                        config.ActiveProfile = ""
                }</span>
        }

        // Ensure active account exists if set
        <span class="cov8" title="1">if config.ActiveAccount != "" </span><span class="cov8" title="1">{
                if _, exists := config.Accounts[config.ActiveAccount]; !exists </span><span class="cov0" title="0">{
                        config.ActiveAccount = ""
                }</span>
        }

        // Marshal config
        <span class="cov8" title="1">data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(filePath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetActiveAccount returns the currently active account
func GetActiveAccount() (string, *Account, error) <span class="cov8" title="1">{
        config := LoadConfig()
        if config.ActiveAccount == "" </span><span class="cov8" title="1">{
                return "", nil, fmt.Errorf("no active account")
        }</span>

        <span class="cov8" title="1">account, exists := config.Accounts[config.ActiveAccount]
        if !exists </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("active account '%s' not found in config", config.ActiveAccount)
        }</span>

        <span class="cov8" title="1">return config.ActiveAccount, &amp;account, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package multigit

import (
    _ "fmt"
    "github.com/cpuix/multigit/internal/ssh"
)

func createSSHKey(accountName, accountEmail, passphrase string) <span class="cov0" title="0">{
    ssh.CreateSSHKey(accountName, accountEmail, passphrase)
}</span>

func addSSHKeyToAgent(accountName string) <span class="cov0" title="0">{
    ssh.AddSSHKeyToAgent(accountName)
}</span>

func addSSHConfigEntry(accountName string) <span class="cov0" title="0">{
    ssh.AddSSHConfigEntry(accountName)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package ssh

import "github.com/stretchr/testify/mock"

// MockSSH is a mock implementation of SSH operations
type MockSSH struct {
        mock.Mock
}

// CreateSSHKey mocks the CreateSSHKey function
func (m *MockSSH) CreateSSHKey(accountName, email, passphrase string) error <span class="cov0" title="0">{
        args := m.Called(accountName, email, passphrase)
        return args.Error(0)
}</span>

// AddSSHKeyToAgent mocks the AddSSHKeyToAgent function
func (m *MockSSH) AddSSHKeyToAgent(accountName string) error <span class="cov0" title="0">{
        args := m.Called(accountName)
        return args.Error(0)
}</span>

// AddSSHConfigEntry mocks the AddSSHConfigEntry function
func (m *MockSSH) AddSSHConfigEntry(accountName string) error <span class="cov0" title="0">{
        args := m.Called(accountName)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package ssh

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

const (
        keyBitSize = 4096
)

// CreateSSHKey creates a new SSH key pair for the given account
func CreateSSHKey(accountName, accountEmail, passphrase string) error <span class="cov8" title="1">{
        // Create .ssh directory if it doesn't exist
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">sshDir := filepath.Join(homeDir, ".ssh")
        if err := os.MkdirAll(sshDir, 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .ssh directory: %w", err)
        }</span>

        // Generate private key
        <span class="cov8" title="1">privateKey, err := rsa.GenerateKey(rand.Reader, keyBitSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Create private key file
        <span class="cov8" title="1">privateKeyFile := filepath.Join(sshDir, fmt.Sprintf("id_rsa_%s", accountName))
        privateKeyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }

        // If passphrase is provided, encrypt the private key
        if passphrase != "" </span><span class="cov8" title="1">{
                privateKeyPEM, err = x509.EncryptPEMBlock(
                        rand.Reader,
                        privateKeyPEM.Type,
                        privateKeyPEM.Bytes,
                        []byte(passphrase),
                        x509.PEMCipherAES256,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt private key: %w", err)
                }</span>
        }

        <span class="cov8" title="1">privateKeyData := pem.EncodeToMemory(privateKeyPEM)
        if err := os.WriteFile(privateKeyFile, privateKeyData, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write private key: %w", err)
        }</span>

        // Create public key
        <span class="cov8" title="1">pubKey, err := sshPublicKey(&amp;privateKey.PublicKey, fmt.Sprintf("%s &lt;%s&gt;", accountName, accountEmail))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate public key: %w", err)
        }</span>

        // Write public key file
        <span class="cov8" title="1">publicKeyFile := fmt.Sprintf("%s.pub", privateKeyFile)
        if err := os.WriteFile(publicKeyFile, pubKey, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write public key: %w", err)
        }</span>

        // Set correct permissions
        <span class="cov8" title="1">if err := os.Chmod(privateKeyFile, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set private key permissions: %w", err)
        }</span>
        <span class="cov8" title="1">if err := os.Chmod(publicKeyFile, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set public key permissions: %w", err)
        }</span>

        // Print success message with public key
        <span class="cov8" title="1">fmt.Printf("‚úÖ SSH key pair created successfully for %s\n", accountName)
        fmt.Printf("Private key: %s\n", privateKeyFile)
        fmt.Printf("Public key: %s\n", publicKeyFile)
        fmt.Println("\nPublic key (add this to your GitHub account):")
        fmt.Println(string(pubKey))

        return nil</span>
}

// sshPublicKey generates the authorized_keys format for the public key
func sshPublicKey(pubKey *rsa.PublicKey, comment string) ([]byte, error) <span class="cov8" title="1">{
        // Convert public key to OpenSSH format
        pubKeyBytes, err := x509.MarshalPKIXPublicKey(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        // Create OpenSSH public key format
        <span class="cov8" title="1">sshPubKey := fmt.Sprintf(
                "ssh-rsa %s %s",
                base64.StdEncoding.EncodeToString(pubKeyBytes),
                comment,
        )

        return []byte(sshPubKey), nil</span>
}

// AddSSHKeyToAgent adds the SSH key to the SSH agent
func AddSSHKeyToAgent(accountName string) error <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">privateKeyFile := filepath.Join(homeDir, ".ssh", fmt.Sprintf("id_rsa_%s", accountName))
        
        // Check if key exists
        if _, err := os.Stat(privateKeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("private key file %s does not exist", privateKeyFile)
        }</span>

        // Check if SSH_AUTH_SOCK is set
        <span class="cov0" title="0">if os.Getenv("SSH_AUTH_SOCK") == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH agent is not running. Please start the SSH agent and try again")
        }</span>

        // Use ssh-add to add the key to the agent
        <span class="cov0" title="0">cmd := exec.Command("ssh-add", privateKeyFile)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add key to SSH agent: %s - %v", string(output), err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ SSH key for %s added to SSH agent\n", accountName)
        return nil</span>
}

// AddSSHConfigEntry adds an entry to the SSH config file
func AddSSHConfigEntry(accountName string) error <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">sshConfigFile := filepath.Join(homeDir, ".ssh", "config")
        privateKeyFile := filepath.Join(homeDir, ".ssh", fmt.Sprintf("id_rsa_%s", accountName))

        // Create config file if it doesn't exist
        f, err := os.OpenFile(sshConfigFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open SSH config file: %w", err)
        }</span>
        <span class="cov8" title="1">defer f.Close()

        // Check if the entry already exists
        configData, err := os.ReadFile(sshConfigFile)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read SSH config file: %w", err)
        }</span>

        <span class="cov8" title="1">hostEntry := fmt.Sprintf(
                "\nHost github.com-%s\n"+
                "\tHostName github.com\n"+
                "\tUser git\n"+
                "\tIdentityFile %s\n"+
                "\tIdentitiesOnly yes\n",
                accountName, privateKeyFile,
        )

        // Check if host already exists in config
        if containsHost(string(configData), fmt.Sprintf("github.com-%s", accountName)) </span><span class="cov0" title="0">{
                return fmt.Errorf("SSH config entry for %s already exists", accountName)
        }</span>

        // Append the new host entry
        <span class="cov8" title="1">if _, err := f.WriteString(hostEntry); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to SSH config: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("‚úÖ Added SSH config entry for %s\n", accountName)
        return nil</span>
}

// DeleteSSHKey deletes the SSH key pair for the given account
func DeleteSSHKey(accountName string) error <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        // Remove private key
        <span class="cov8" title="1">privateKeyFile := filepath.Join(homeDir, ".ssh", fmt.Sprintf("id_rsa_%s", accountName))
        if err := os.Remove(privateKeyFile); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove private key: %w", err)
        }</span>

        // Remove public key
        <span class="cov8" title="1">publicKeyFile := fmt.Sprintf("%s.pub", privateKeyFile)
        if err := os.Remove(publicKeyFile); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove public key: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("‚úÖ Removed SSH key pair for %s\n", accountName)
        return nil</span>
}

// RemoveSSHConfigEntry removes the SSH config entry for the given account
func RemoveSSHConfigEntry(accountName string) error <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">sshConfigFile := filepath.Join(homeDir, ".ssh", "config")
        
        // Check if config file exists
        configData, err := os.ReadFile(sshConfigFile)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // Nothing to remove
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read SSH config file: %w", err)
        }</span>

        <span class="cov8" title="1">hostPattern := fmt.Sprintf("github.com-%s", accountName)
        updatedConfig := removeHostEntry(string(configData), hostPattern)

        // Only write if config was changed
        if updatedConfig != string(configData) </span><span class="cov8" title="1">{
                if err := os.WriteFile(sshConfigFile, []byte(updatedConfig), 0600); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update SSH config: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("‚úÖ Removed SSH config entry for %s\n", accountName)</span>
        } else<span class="cov8" title="1"> {
                fmt.Printf("‚ÑπÔ∏è No SSH config entry found for %s\n", accountName)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Helper function to check if a host entry already exists
func containsHost(configData, host string) bool <span class="cov8" title="1">{
        hostPattern := fmt.Sprintf("\nHost %s", host)
        return strings.Contains(configData, hostPattern) || 
               strings.HasPrefix(configData, fmt.Sprintf("Host %s", host))
}</span>

// Helper function to remove a host entry from SSH config
func removeHostEntry(configData, hostPattern string) string <span class="cov8" title="1">{
        lines := strings.Split(configData, "\n")
        var result []string
        inHostBlock := false

        for i := 0; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := lines[i]
                if strings.HasPrefix(strings.TrimSpace(line), "Host ") </span><span class="cov8" title="1">{
                        // Check if this is the host we want to remove
                        if strings.Contains(line, hostPattern) </span><span class="cov8" title="1">{
                                inHostBlock = true
                                continue</span>
                        }
                        <span class="cov8" title="1">inHostBlock = false</span>
                }

                <span class="cov8" title="1">if !inHostBlock </span><span class="cov8" title="1">{
                        result = append(result, line)
                }</span>
        }

        <span class="cov8" title="1">return strings.Join(result, "\n")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package ssh

// SSHOperations defines the interface for SSH-related operations
type SSHOperations interface {
        CreateSSHKey(accountName, email, passphrase string) error
        AddSSHKeyToAgent(accountName string) error
        AddSSHConfigEntry(accountName string) error
        DeleteSSHKey(accountName string) error
        RemoveSSHConfigEntry(accountName string) error
}

// DefaultSSH implements the default SSH operations
type DefaultSSH struct{}

// CreateSSHKey creates a new SSH key pair
func (d *DefaultSSH) CreateSSHKey(accountName, email, passphrase string) error <span class="cov0" title="0">{
        return CreateSSHKey(accountName, email, passphrase)
}</span>

// AddSSHKeyToAgent adds the SSH key to the SSH agent
func (d *DefaultSSH) AddSSHKeyToAgent(accountName string) error <span class="cov0" title="0">{
        return AddSSHKeyToAgent(accountName)
}</span>

// AddSSHConfigEntry adds an entry to the SSH config file
func (d *DefaultSSH) AddSSHConfigEntry(accountName string) error <span class="cov0" title="0">{
        return AddSSHConfigEntry(accountName)
}</span>

// DeleteSSHKey deletes the SSH key pair
func (d *DefaultSSH) DeleteSSHKey(accountName string) error <span class="cov8" title="1">{
        return DeleteSSHKey(accountName)
}</span>

// RemoveSSHConfigEntry removes the SSH config entry
func (d *DefaultSSH) RemoveSSHConfigEntry(accountName string) error <span class="cov8" title="1">{
        return RemoveSSHConfigEntry(accountName)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package multigit

import "github.com/cpuix/multigit/cmd"

func main() <span class="cov0" title="0">{
    cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"

        "github.com/cpuix/multigit/cmd"
        "github.com/cpuix/multigit/internal/multigit"
        "github.com/stretchr/testify/require"
)

// SetupTestConfig creates a test configuration file and initializes the config
func SetupTestConfig(t *testing.T, tempDir string) <span class="cov8" title="1">{
        t.Helper()
        
        // Create test config
        config := multigit.NewConfig()
        config.Accounts["test-account"] = multigit.Account{
                Name:  "Test User",
                Email: "test@example.com",
        }

        // Save config
        cfgPath := filepath.Join(tempDir, "config.json")
        err := multigit.SaveConfigToFile(config, cfgPath)
        require.NoError(t, err, "Failed to save test config")

        // Set config path
        cmd.CfgFile = cfgPath
        cmd.InitConfig()
}</span>

// SetupGitRepo creates a test git repository in a temporary directory
func SetupGitRepo(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()
        
        tempDir := t.TempDir()
        gitDir := filepath.Join(tempDir, ".git")
        err := os.Mkdir(gitDir, 0755)
        require.NoError(t, err, "Failed to create .git directory")
        
        return tempDir
}</span>

// Chdir changes the current working directory and returns a cleanup function
func Chdir(t *testing.T, dir string) func() <span class="cov0" title="0">{
        t.Helper()
        
        oldDir, err := os.Getwd()
        require.NoError(t, err, "Failed to get current working directory")
        
        err = os.Chdir(dir)
        require.NoError(t, err, "Failed to change directory")
        
        return func() </span><span class="cov0" title="0">{
                err := os.Chdir(oldDir)
                require.NoError(t, err, "Failed to restore working directory")
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
